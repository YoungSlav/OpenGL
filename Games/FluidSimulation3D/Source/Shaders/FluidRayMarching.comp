#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D outputTexture;
layout(r32f, binding = 1) uniform image3D densitiesMap;

const float FLT_MAX = 3.402823466e+38;
const float PI = 3.14159265359;


uniform vec3 eyeLocation;
uniform mat4 invProjMat;
uniform mat4 invViewMat;

uniform float DensitiesResolutionInverse;
uniform vec3 BoundsSize;
uniform vec3 BoundsOrigin;
uniform mat4 BoundingBox;
uniform mat4 inverseBoundingBox;

uniform float MarchingRayStep;
uniform float DensityMultiplier;

uniform vec3 ScatteringCoefficients;

const uint GridLookupCount = 27;
const ivec3 GridOffsets[GridLookupCount] = ivec3[](
    ivec3(0, 0, 0),
    ivec3(1, 0, 0),
    ivec3(-1, 0, 0),
    ivec3(0, 1, 0),
    ivec3(0, -1, 0),
    ivec3(0, 0, 1),
    ivec3(0, 0, -1),
    ivec3(1, 1, 0),
    ivec3(1, -1, 0),
    ivec3(-1, 1, 0),
    ivec3(-1, -1, 0),
    ivec3(1, 0, 1),
    ivec3(1, 0, -1),
    ivec3(-1, 0, 1),
    ivec3(-1, 0, -1),
    ivec3(0, 1, 1),
    ivec3(0, 1, -1),
    ivec3(0, -1, 1),
    ivec3(0, -1, -1),
    ivec3(1, 1, 1),
    ivec3(1, 1, -1),
    ivec3(1, -1, 1),
    ivec3(1, -1, -1),
    ivec3(-1, 1, 1),
    ivec3(-1, 1, -1),
    ivec3(-1, -1, 1),
    ivec3(-1, -1, -1)
);


float CalcDensity(vec3 location);

// kernels
float DensityKernel(float dst);

// grid helpers
ivec3 GetCellCoord(vec3 Position);
uint GetCellHash(ivec3 Coords);
uint CellIndexFromHash(uint Hash);


// marching
struct Ray
{
    vec3 origin;
    vec3 dir;
};


bool IntersectRayBox(Ray ray, out vec3 hitLocation, out float distInsideCube2);
float RayMarch(vec3 dir, vec3 origin, float marchingDist2);


void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iSize = imageSize(outputTexture);
    if (pixelCoord.x >= iSize.x || pixelCoord.y >= iSize.y)
    {
        return;  // Ignore out-of-bounds invocations
    }

    // Convert pixel coordinates to NDC
    vec2 ndc = vec2(
        (2.0 * pixelCoord.x) / iSize.x - 1.0,
        (2.0 * pixelCoord.y) / iSize.y - 1.0
    );

    vec4 clipCoord = vec4(ndc, -1.0, 1.0);

    vec4 viewCoord = invProjMat * clipCoord;
    viewCoord /= viewCoord.w;

    vec3 worldCoord = (invViewMat * vec4(viewCoord.xyz, 1.0)).xyz;

    vec3 camRight = vec3(invViewMat[0][0], invViewMat[0][1], invViewMat[0][2]);
    vec3 camUp = vec3(invViewMat[1][0], invViewMat[1][1], invViewMat[1][2]);
        
    Ray ray;
    ray.origin = eyeLocation;
    ray.dir = normalize(worldCoord - eyeLocation);

    vec4 Color = vec4(0.0f);
    
    vec3 hitLocation;
    float marchingDistance2;
    if ( IntersectRayBox(ray, hitLocation, marchingDistance2) )
    {
        float totalLight = RayMarch(ray.dir, hitLocation, marchingDistance2);
        
        Color = vec4(vec3(totalLight), totalLight > 0.0 ? 0.8f : 0.0f);
    }

    imageStore(outputTexture, pixelCoord, Color);
};

float RayMarch(vec3 dir, vec3 origin, float marchingDist2)
{
    float totalDensity = 0.0f;

    
    for (float coveredDst = 0.0f; coveredDst*coveredDst < marchingDist2; coveredDst += MarchingRayStep)
    {
        vec3 samplePoint = origin + dir * coveredDst;
        float density = CalcDensity(samplePoint) * MarchingRayStep * DensityMultiplier;

        totalDensity += density;
                
    }
    
    return totalDensity;
}

float CalcDensity(vec3 location)
{
    vec3 localPoint = (inverseBoundingBox * vec4(location, 1.0)).xyz;
    localPoint = localPoint + vec3(0.5f);
    ivec3 mapSize = imageSize(densitiesMap);
    vec3 sampleCoord = localPoint * vec3(mapSize);

    float Density = imageLoad(densitiesMap, ivec3(sampleCoord.xyz)).r;
       
    return Density;
}

bool IntersectRayBox(Ray worldRay, out vec3 hitLocation, out float distInsideCube2)
{
    Ray ray;
    ray.origin = (inverseBoundingBox * vec4(worldRay.origin, 1.0)).xyz;
    ray.dir = normalize((inverseBoundingBox * vec4(worldRay.dir, 0.0)).xyz);

    // Box bounds
    vec3 minBound = vec3(-0.5f);
    vec3 maxBound = vec3(0.5f);

    // Calculate the t-values for intersection with each slab
    vec3 tMin = (minBound - ray.origin) / ray.dir;
    vec3 tMax = (maxBound - ray.origin) / ray.dir;

    // Ensure tMin < tMax
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    // Find the largest entry t and the smallest exit t
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    // If tNear > tFar or tFar < 0, there is no intersection
    if (tNear > tFar || tFar < 0.0)
    {
        return false;
    }

    // Populate the hit info
    hitLocation = ray.origin + ray.dir * tNear;
    vec3 hitFar = ray.origin + ray.dir * tFar;

    hitLocation = (BoundingBox * vec4(hitLocation, 0.0)).xyz;
    hitFar = (BoundingBox * vec4(hitFar, 0.0)).xyz;

    //float scaleToWorld = length((BoundingBox * vec4(ray.dir, 1)).xyz);
    //float nearDistance = scaleToWorld * tFar;
    //float farDistance = scaleToWorld * tFar;

    vec3 offset = (hitFar - hitLocation);

    distInsideCube2 = dot(offset, offset);

    return true;
}