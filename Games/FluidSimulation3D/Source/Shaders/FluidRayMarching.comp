#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D outputTexture;

uniform vec3 eyeLocation;
uniform mat4 invProjMat;
uniform mat4 invViewMat;

const float FLT_MAX = 3.402823466e+38;
const float PI = 3.14159265359;


struct Ray
{
    vec3 origin;
    vec3 dir;
};

struct HitInfo
{
    bool bHit;
    float dst2;
    vec3 hitLocation;
    vec3 hitNormal;

    uint componentIndex;
};

float RandomValue(inout uint seed);
float RandomValueNormalDistr(inout uint seed);
vec3 RandomDirection(inout uint seed);
vec3 RandomHemisphereDirection(inout uint seed, vec3 dir);
vec2 RandomCirclePoint(inout uint seed);


void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iSize = imageSize(outputTexture);
    if (pixelCoord.x >= iSize.x || pixelCoord.y >= iSize.y)
    {
        return;  // Ignore out-of-bounds invocations
    }

    // Convert pixel coordinates to NDC
    vec2 ndc = vec2(
        (2.0 * pixelCoord.x) / iSize.x - 1.0,
        (2.0 * pixelCoord.y) / iSize.y - 1.0
    );

    vec4 clipCoord = vec4(ndc, -1.0, 1.0);

    vec4 viewCoord = invProjMat * clipCoord;
    viewCoord /= viewCoord.w;

    vec3 worldCoord = (invViewMat * vec4(viewCoord.xyz, 1.0)).xyz;

    vec3 camRight = vec3(invViewMat[0][0], invViewMat[0][1], invViewMat[0][2]);
    vec3 camUp = vec3(invViewMat[1][0], invViewMat[1][1], invViewMat[1][2]);

    vec2 aaJitter = vec2(0.0f);//RandomCirclePoint(rndSeed) * antiAliasingStrength / iSize.x;
    vec3 aaOfset = camRight * aaJitter.x + camUp * aaJitter.y;

    worldCoord = worldCoord + aaOfset;
    
    Ray ray;
    ray.origin = eyeLocation;
    ray.dir = normalize(worldCoord - eyeLocation);    
    

    vec3 newColor = vec3(1.0f);
    imageStore(outputTexture, pixelCoord, vec4(newColor, 1.0));
};

// TODO: replace me?
float RandomValue(inout uint seed)
{
    seed = seed * 747796405 + 2891336453;
    uint result = ((seed >> ((seed >> 28) + 4)) ^ seed) * 277803737;
    result = (result >> 22) ^ result;
    return result / 4294967295.0;
}

float RandomValueNormalDistr(inout uint seed)
{
    float t = 2.0 * PI * RandomValue(seed);
    float r = sqrt(-2 * log(RandomValue(seed)));
    return r * cos(t);
}

vec3 RandomDirection(inout uint seed)
{
    vec3 result = vec3(0);
    result.x = RandomValueNormalDistr(seed);
    result.y = RandomValueNormalDistr(seed);
    result.z = RandomValueNormalDistr(seed);
    return normalize(result);
}

vec3 RandomHemisphereDirection(inout uint seed, vec3 dir)
{
    vec3 result = RandomDirection(seed);
    return result * sign(dot(result, dir));
}

vec2 RandomCirclePoint(inout uint seed)
{
    float angle = RandomValue(seed) * 2.0 * PI;
    vec2 point = vec2(cos(angle), sin(angle));
    return point * sqrt(RandomValue(seed));
}